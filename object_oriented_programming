# Procedural Programming -- code as a sequence of steps, great for data analysis and scripts
# Object-oriented programming (bundle data with code operating the data) 
-- code as interactions of objects, great for building frameworks and tools, miantainable and reusable code
-- Object = State (= features/ attributes) + Behaviour ( = actions/ methods)
    -- e.g. array1 = np.array([1, 2, 3, 4, 5])
        -- array1.shape = attribute e.g. object.attribute
        -- array1.reshape(5, 1) = method e.g. object.method()
    -- e.g. dir(object) returns all the attributes and methods on an object
-- Class: blueprint for objects outlining possible states and behaviours

# everything in Python is an object 
-- every object has a class (int, str, DataFrame, function, etc.)
    -- e.g. type(object) = class name

# 
class ClassName:
    # pass (for empty class)
    def func1(self, var1, var2): # every method (function) under the class must have a self as the first argument
        self.attribute1 = var1
        self.attribute2 = var2
        print('', var1)
    def func2(self):
        print('', self.attribute1)
#
obj1 = ClassName()
obj2 = ClassName() # 
#
obj3 = ClassName()
obj3.func1(var1) # this is actually equal to: ClassName.func1(Classname, var1)
obj3.func2()






